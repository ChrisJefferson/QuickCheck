<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (quickcheck) - Chapter 2: Tutorial</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap2"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap2_mj.html">[MathJax on]</a></p>
<p><a id="X81932F777898AD72" name="X81932F777898AD72"></a></p>
<div class="ChapSects"><a href="chap2.html#X81932F777898AD72">2 <span class="Heading">Tutorial</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7963B97E7D6DAB76">2.1 <span class="Heading">Using QuickCheck</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7F0DDD408227897B">2.2 <span class="Heading">Valid argument types for QuickCheck</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7B293DA97FE16E27">2.3 <span class="Heading">Adding new types to QuickCheck</span></a>
</span>
</div>
</div>

<h3>2 <span class="Heading">Tutorial</span></h3>

<p><a id="X7963B97E7D6DAB76" name="X7963B97E7D6DAB76"></a></p>

<h4>2.1 <span class="Heading">Using QuickCheck</span></h4>

<p>The idea behind QuickCheck is to write functions which should always return true, or two functions which should always return the same value. We then feed those functions many different inputs, and see if that behaviour holds.</p>

<p>While this cannot detect all bugs, it can catch many issues. In particular, the code can catch issues with small inputs, or edge conditions. This tutorial will walk through the major functionality of the QuickCheck package through examples.</p>

<p>As a first example, let's test if GAP's integers are commutative -- that is if <span class="Math">a*b = b*a</span>. We first make a function which takes two arguments and returns <code class="code">true</code> if the inputs are commutative. We test this using <code class="code">QC_Check</code>. <code class="code">QC_Check</code> has two mandatory arguments, firstly the types of the arguments of the functions we want to test, and secondly the function to test.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">testFunc := function(a,b)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return a*b = b*a;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QC_Check([IsInt, IsInt], testFunc);</span>
true
</pre></div>

<p>Great! We can use the same function to test if other types are commutative:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QC_Check([IsPerm, IsPerm], testFunc);</span>
Test 60 of 500 failed:
 Input: [ (1,3), (1,3,2) ]
 Output: false
false
</pre></div>

<p>Turns out multiplication of permutations is not commutative! This isn't a surprise, of course...</p>

<p>If we want to analyse those arguments, we can access them through <code class="code">QC_LastFailure</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QC_LastFailure();</span>
rec( args := [ (1,3), (1,3,2) ], func := function( a, b ) ... end )
</pre></div>

<p>Rather than running a single function and checking if it returns <code class="code">true</code>, we can run two functions and test if they produce the same output. For example, let's compare two methods of intersecting groups -- GAP's optimised implementation and a "brute force" method which just finds the elements in both groups:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">slowIntersection := function(g,h)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     return Group(Filtered(g, p -&gt; p in h));</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QC_CheckEqual([IsPermGroup, IsPermGroup], Intersection, slowIntersection);</span>
true
</pre></div>

<p>Could we be more efficient? How about if we just test which generators of <code class="code">g</code> are in <code class="code">h</code>?</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">genIntersection := function(g,h)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   return Group(Filtered(GeneratorsOfGroup(g), p -&gt; p in h), ());</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QC_CheckEqual([IsPermGroup, IsPermGroup], Intersection, genIntersection);</span>
Test 97 of 500 failed:
 Input: [ Group( [ (1,2,3), (2,3,4) ] ), Group( [ (1,4)(2,3), (1,2)(3,4) ] ) ]
 Output: Return values differ: Group( [ (1,4)(2,3), (1,2)(3,4) ] ) and Group( () )
false
</pre></div>

<p>No, unfortunately not! You may be surprised it took until test 97 to find this bug (you may also get different results). This is because QuickCheck starts by making many very small tests, which are fast to execute (finding this bad example takes less than a tenth of a second).</p>

<p>In some cases, the inputs given might not make sense for the function we are testing. For example, imagine we want to test if <span class="Math">b*(a/b) = a</span>. This statement isn't valid for <span class="Math">b=0</span>. We can skip invalid values by return the special value <code class="code">QC_Skip</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">checkDiv := function(a,b)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if b = 0 then return QC_Skip; fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return b*(a/b);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">justA := function(a,b)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">return a;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QC_CheckEqual([IsInt, IsInt], checkDiv, justA);</span>
true
</pre></div>

<p>In some cases we might want to return an explanation of why a test failed. Rather than returning <code class="code">false</code> from <code class="code">QC_Equal</code>, you can instead return a string. Returning a string is treated as a failure, and the string is printed out to the user.</p>

<p><a id="X7F0DDD408227897B" name="X7F0DDD408227897B"></a></p>

<h4>2.2 <span class="Heading">Valid argument types for QuickCheck</span></h4>

<p>The set of elements which can be given to QuickCheck tests is listed below. The list is always growing, and please submit an issue on GitHub if you have any specific requests.</p>

<p>The currently allowed argument types for QuickCheck are:</p>


<ul>
<li><p>IsInt : An integer</p>

</li>
<li><p>IsPosInt : A positive integer</p>

</li>
<li><p>IsNegInt : A negative integer</p>

</li>
</ul>

<ul>
<li><p>IsRat : Rational number</p>

</li>
<li><p>IsPosRat : Positive rational number</p>

</li>
<li><p>IsNegRat : Negative rational number</p>

</li>
</ul>

<ul>
<li><p>IsPerm : A permutation</p>

</li>
<li><p>IsTransformation : A transformation</p>

</li>
<li><p>IsPermGroup : A permutation group</p>

</li>
</ul>

<ul>
<li><p>IsDigraph : A digraph (requires the Digraph package)</p>

</li>
</ul>
<p>There is also a generic function to take a random member from a collection:</p>


<ul>
<li><p>QC_ElementOf(x) : Return a random member of the list x</p>

</li>
</ul>
<p>This can be used to take a random element of a small list of options ( like [1,2,3] ), or a random element of a collection which is not explicitly listed above (like AlternatingGroup(7) ). The disadvantage of using QC_ElementOf is that it does not handle 'limit' well, but will instead take a random element from x.</p>

<p>There are also ways of defining lists or sets of arguments, recursively:</p>


<ul>
<li><p>QC_ListOf(x) : A (possibly empty) list of items of type x</p>

</li>
<li><p>QC_SetOf(x) : A (possibly empty) set of items of type x</p>

</li>
<li><p>QC_PairOf(x) : A pair of items of type x</p>

</li>
<li><p>QC_FixedLengthListOf(x, len) : A list of length len of items of type x</p>

</li>
</ul>
<p>In some cases this may not be sufficient, for example an algorithm may require an integer which is not prime. The function can return the special value QC_Skip, which skips this test. If too many tests are skipped, the tester will eventually stop generating new arguments. For example, if we want to check the AlternatingGroup(n) is a strict subgroup of the SymmetricGroup(n) for n &gt; 2.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function(x)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local a, s;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if x &lt; 2 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        return QC_Skip;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    a := AlternatingGroup(x);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    s := SymmetricGroup(x);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if not IsSubgroup(s, a) then return "Not a subgroup"; fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if s = a then return "Equal!"; fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return true;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QC_Check([IsInt], func);</span>
true
</pre></div>

<p><a id="X7B293DA97FE16E27" name="X7B293DA97FE16E27"></a></p>

<h4>2.3 <span class="Heading">Adding new types to QuickCheck</span></h4>

<p>QuickCheck takes a list of the arguments for the function to be tested, so it needs to know how to generate values of any given type. There is a built-in list of types and new ones can be easily added.</p>

<p>All value generators are a function which takes two arguments -- the first is a RandomSource, and the second is a positive integer representing the maximum "size" of the value created (each type can choose how to interpret this).</p>

<p>For example, here are generators for a positive integer and a permutation.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">makePosInt := function(rs, limit)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   return Random(rs, [1..limit]);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">makePerm := function(rs, limit)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   return Random(rs, SymmetricGroup(limit));</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
</pre></div>

<p>These functions can be used immediately in QC_Check:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QC_Check([makePosInt, makePerm, makePerm], {r,p1,p2} -&gt; (r^p1)^p2 = r^(p1*p2));</span>
true
</pre></div>

<p>These functions can also be registered with the filter which they implement, using QC_RegisterFilterGen:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gap&gt; QC_RegisterFilterGen(IsPosInt, makePosInt);</span>
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="https://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
